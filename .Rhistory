function(
ML_est,
params = list(prev = NULL, se = NULL, sp = NULL, D = NULL)){
prog_plots <- c("prev", "se", "sp", "A2", "B2", "qk")
n_method <- length(ML_est@results$se_est)
### Se/Sp scatter plot
se_sp_data <-
left_join(
as.data.frame(ML_est@prog$se) %>% mutate(iter = row_number()) %>% pivot_longer(!iter, names_to = "method", values_to = "se"),
as.data.frame(ML_est@prog$sp) %>% mutate(iter = row_number()) %>% pivot_longer(!iter, names_to = "method", values_to = "sp"),
by = join_by(iter, method)
)
se_sp_result <-
data.frame(
method = rep(colnames(ML_est@results$se_est), 2),
se = c(ML_est@results$se_est, params$se) %>% rep(2 * n_method / length(.)), #fix
sp = c(ML_est@results$sp_est, params$sp) %>% rep(2 * n_method / length(.)), #fix
shape = c(
rep("final", n_method),
rep("param", n_method)
)
)
se_sp_plot <-
se_sp_data %>%
ggplot(aes(x = sp, y = se, group = method, color = method)) +
geom_line() +
geom_point(data = se_sp_result, aes(shape = shape)) +
scale_shape_manual(values = c(16, 1)) +
geom_line(data = se_sp_result, lty = 2) +
coord_fixed() +
scale_y_continuous("Sensitivity", limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_x_continuous("Specificity", limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_color_brewer(palette = "Set1") +
theme(panel.background = element_blank(),
panel.grid = element_line(color = "gray80"),
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
### ML progress plots
dis_data <- # disease status
data.frame(
D = paste("Class", as.character(as.numeric(params$D))),
group = as.character(names(params$D)))
list_prog_plots <-
lapply(prog_plots, function(j){
df_plot <- as.data.frame(pluck(ML_est, "prog", j)) %>%
mutate(iter = row_number())
df_plot %>%
pivot_longer(!iter, names_to = "group", values_to = "value") %>%
left_join(dis_data, by = "group") %>%
replace_na(list(D = "Class unknown")) %>%
mutate(color_col = case_when( # define which column to color lines by
j %in% c("A2", "B2", "qk") ~ D,
j %in% c("se", "sp") ~ group,
j %in% c("prev") ~ "Estimate")) %>%
ggplot(aes(x = iter, y = value, group = group, color = color_col)) +
geom_line() +
scale_y_continuous(j, limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_x_continuous("Iteration", limits = c(0, ML_est@iter)) +
scale_color_brewer("", palette = "Set1", na.value = "gray30", drop = FALSE) +
theme(panel.background = element_blank(),
panel.grid = element_line(color = "gray80"),
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
legend.position = "bottom")
})
### Output
return(
c(
list_prog_plots,
list(se_sp_plot)
)
)
}
plot(b)
plot_ML_binary <-
function(
ML_est,
params = list(prev = NULL, se = NULL, sp = NULL, D = NULL)){
prog_plots <- c("prev", "se", "sp", "A2", "B2", "qk")
n_method <- length(ML_est@results$se_est)
### Se/Sp scatter plot
se_sp_data <-
left_join(
as.data.frame(ML_est@prog$se) %>% mutate(iter = row_number()) %>% pivot_longer(!iter, names_to = "method", values_to = "se"),
as.data.frame(ML_est@prog$sp) %>% mutate(iter = row_number()) %>% pivot_longer(!iter, names_to = "method", values_to = "sp"),
by = join_by(iter, method)
)
se_sp_result <-
data.frame(
method = rep(colnames(ML_est@results$se_est), 2),
se = c(ML_est@results$se_est, params$se) %>% rep(2 * n_method / length(.)), #fix
sp = c(ML_est@results$sp_est, params$sp) %>% rep(2 * n_method / length(.)), #fix
shape = c(
rep("final", n_method),
rep("param", n_method)
)
)
se_sp_plot <-
se_sp_data %>%
ggplot(aes(x = sp, y = se, group = method, color = method)) +
geom_line() +
geom_point(data = se_sp_result, aes(shape = shape)) +
scale_shape_manual(values = c(16, 1)) +
geom_line(data = se_sp_result, lty = 2) +
coord_fixed() +
scale_y_continuous("Sensitivity", limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_x_continuous("Specificity", limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_color_brewer(palette = "Set1") +
theme(panel.background = element_blank(),
panel.grid = element_line(color = "gray80"),
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
### ML progress plots
dis_data <- # disease status
data.frame(
D = as.character(as.numeric(params$D)),
group = as.character(names(params$D))) %>%
mutate(D = paste("Class", D))
list_prog_plots <-
lapply(prog_plots, function(j){
df_plot <- as.data.frame(pluck(ML_est, "prog", j)) %>%
mutate(iter = row_number())
df_plot %>%
pivot_longer(!iter, names_to = "group", values_to = "value") %>%
left_join(dis_data, by = "group") %>%
replace_na(list(D = "Class unknown")) %>%
mutate(color_col = case_when( # define which column to color lines by
j %in% c("A2", "B2", "qk") ~ D,
j %in% c("se", "sp") ~ group,
j %in% c("prev") ~ "Estimate")) %>%
ggplot(aes(x = iter, y = value, group = group, color = color_col)) +
geom_line() +
scale_y_continuous(j, limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_x_continuous("Iteration", limits = c(0, ML_est@iter)) +
scale_color_brewer("", palette = "Set1", na.value = "gray30", drop = FALSE) +
theme(panel.background = element_blank(),
panel.grid = element_line(color = "gray80"),
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
legend.position = "bottom")
})
### Output
return(
c(
list_prog_plots,
list(se_sp_plot)
)
)
}
plot(b)
plot(b, a$params)
plot(b, params = a$params)
plot_ML_binary <-
function(
ML_est,
params = list(prev = NULL, se = NULL, sp = NULL, D = NULL)){
prog_plots <- c("prev", "se", "sp", "A2", "B2", "qk")
n_method <- length(ML_est@results$se_est)
### Se/Sp scatter plot
# create long data frame of sequence of se/sp estimates
se_sp_data <-
left_join(
as.data.frame(ML_est@prog$se) %>% mutate(iter = row_number()) %>% pivot_longer(!iter, names_to = "method", values_to = "se"),
as.data.frame(ML_est@prog$sp) %>% mutate(iter = row_number()) %>% pivot_longer(!iter, names_to = "method", values_to = "sp"),
by = join_by(iter, method)
)
# create data frame containing final estimate and true value, if known. This is for assessing accuracy of estimates in simulations when true value is known.
se_sp_result <-
data.frame(
method = rep(colnames(ML_est@results$se_est), 2),
se = c(ML_est@results$se_est, params$se) %>% rep(2 * n_method / length(.)),
sp = c(ML_est@results$sp_est, params$sp) %>% rep(2 * n_method / length(.)),
shape = c(
rep("final", n_method),
rep("truth", n_method)
)
)
# create se/sp line plot showing change in estimates over time
se_sp_plot <-
se_sp_data %>%
ggplot(aes(x = sp, y = se, group = method, color = method)) +
geom_line() +
geom_point(data = se_sp_result, aes(shape = shape)) +
scale_shape_manual(values = c(16, 1)) +
geom_line(data = se_sp_result, lty = 2) +
coord_fixed() +
scale_y_continuous("Sensitivity", limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_x_continuous("Specificity", limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_color_brewer(palette = "Set1") +
theme(panel.background = element_blank(),
panel.grid = element_line(color = "gray80"),
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
### ML progress plots
dis_data <- # disease status
data.frame(
D = as.character(as.numeric(params$D)),
group = as.character(names(params$D))) %>%
mutate(D = paste("Class", D))
list_prog_plots <-
lapply(prog_plots, function(j){
df_plot <- as.data.frame(pluck(ML_est, "prog", j)) %>%
mutate(iter = row_number())
df_plot %>%
pivot_longer(!iter, names_to = "group", values_to = "value") %>%
left_join(dis_data, by = "group") %>%
replace_na(list(D = "Class unknown")) %>%
mutate(color_col = case_when( # define which column to color lines by
j %in% c("A2", "B2", "qk") ~ D,
j %in% c("se", "sp") ~ group,
j %in% c("prev") ~ "Estimate")) %>%
ggplot(aes(x = iter, y = value, group = group, color = color_col)) +
geom_line() +
scale_y_continuous(j, limits = c(0, 1), breaks = seq(0, 1, 0.1), expand = c(0, 0)) +
scale_x_continuous("Iteration", limits = c(0, ML_est@iter)) +
scale_color_brewer("", palette = "Set1", na.value = "gray30", drop = FALSE) +
theme(panel.background = element_blank(),
panel.grid = element_line(color = "gray80"),
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
legend.position = "bottom")
})
### Output
return(
c(
list_prog_plots,
list(se_sp_plot)
)
)
}
plot(b)
all(c("a", "b") %in% c("a", "b", "c"))
all(c("a", "d") %in% c("a", "b", "c"))
all(c("b", "b") %in% c("a", "b", "c"))
all(c("d", "b") %in% c("a", "b", "c"))
estimate_ML_binary <-
function(data,
init = list(prev_1 = NULL, se_1 = NULL, sp_1 = NULL),
max_iter = 100,
tol = 1e-7,
save_progress = TRUE){
calc_A2 <- function(){
data |>
apply(1, FUN = function(y) (se_m ^ y) * ((1 - se_m) ^ (1 - y))) |>
apply(2, FUN = function(z) prod(z, na.rm = TRUE)) |>
(\(x) x * prev_m)()
}
calc_B2 <- function(){
data |>
apply(1, FUN = function(y) ((1 - sp_m) ^ y) * (sp_m ^ (1 - y))) |>
apply(2, FUN = function(z) prod(z, na.rm = TRUE)) |>
(\(x) x * (1 - prev_m))()
}
calc_qk <- function(A2, B2){
A2 / (A2 + B2)
}
calc_next_se <- function(){
data_mat <- as.matrix(data)
data_mat[is.na(data_mat)] <- 0 # added to handle NA, used to calc appropriate denominators
(qk_m %*% data_mat) / (qk_m %*% !is.na(as.matrix(data)))
# (qk_m %*% as.matrix(data)) / sum(qk_m) # original function before changes to accept NA
}
calc_next_sp <- function(){
data_mat <- 1 - as.matrix(data)
data_mat[is.na(data_mat)] <- 0 # added to handle NA, used to calc appropriate denominators
((1 - qk_m) %*% data_mat) / ((1 - qk_m) %*% !is.na(as.matrix(data)))
# ((1 - qk_m) %*% (1 - as.matrix(data))) / sum(1 - qk_m) # original function before changes to accept NA
}
calc_next_prev <- function(){
mean(qk_m)
}
if(!all(c("prev_1", "se_1", "sp_1") %in% names(init)) | any(sapply(init, is.null))){init <- pollinate_ML_binary(data)}
method_names <- if(is.null(colnames(data))){name_thing("method", ncol(data))}else{colnames(data)}
obs_names <- if(is.null(rownames(data))){name_thing("obs", nrow(data))}else{rownames(data)}
dimnames(data) <- list(obs_names, method_names)
# starting values
se_m <- init$se_1
sp_m <- init$sp_1
prev_m <- init$prev_1
# initialize lists
list_se <- list()
list_sp <- list()
list_prev <- list()
list_A2 <- list()
list_B2 <- list()
list_qk <- list()
converged <- FALSE
iter <- 1
# iterate
for(iter in 1:max_iter){
A2_m <- calc_A2()
B2_m <- calc_B2()
qk_m <- calc_qk(A2_m, B2_m)
list_se <- c(list_se, list(se_m))
list_sp <- c(list_sp, list(sp_m))
list_prev <- c(list_prev, list(prev_m))
list_A2 <- c(list_A2, list(A2_m))
list_B2 <- c(list_B2, list(B2_m))
list_qk <- c(list_qk, list(qk_m))
if(iter > 1){
if(
max(abs(list_se[[iter]] - list_se[[iter - 1]]),
abs(list_sp[[iter]] - list_sp[[iter - 1]]),
abs(list_prev[[iter]] - list_prev[[iter - 1]])) < tol){
break}
}
se_m <- calc_next_se()
sp_m <- calc_next_sp()
prev_m <- calc_next_prev()
iter <- iter + 1
}
prev_prog <- do.call(rbind, list_prev)
se_prog <- do.call(rbind, list_se)
sp_prog <- do.call(rbind, list_sp)
A2_prog <- do.call(rbind, list_A2)
B2_prog <- do.call(rbind, list_B2)
qk_prog <- do.call(rbind, list_qk)
output <-
new("MultiMethodMLEstimate",
results = list(
prev_est = unlist(prev_m),
se_est = unlist(se_m),
sp_est = unlist(sp_m)),
iter = iter,
type = "binary")
if(save_progress){
output@prog <-
list(
prev = prev_prog,
se = se_prog,
sp = sp_prog,
A2 = A2_prog,
B2 = B2_prog,
qk = qk_prog
)
}
return(output)
}
estimate_ML_binary(a$generated_data)
estimate_ML_binary(a$generated_data, init = list())
estimate_ML_binary(a$generated_data, init = list(se_1 = 0.99, sp_1 = 0.75, prev_1 = 0.001))
b <- estimate_ML_binary(a$generated_data, init = list(se_1 = 0.99, sp_1 = 0.75, prev_1 = 0.001))
plot(b)
b <- estimate_ML_binary(a$generated_data, init = list(se_1 = runif(3), sp_1 = runif(3), prev_1 = 0.001))
plot(b)
b <- estimate_ML_binary(a$generated_data, init = list(se_1 = runif(3), sp_1 = runif(3), prev_1 = 0.1))
plot(b)
plot(b)
b <- estimate_ML_binary(a$generated_data, init = list(se_1 = runif(3), sp_1 = runif(3), prev_1 = 0.1))
plot(b)
b <- estimate_ML_binary(a$generated_data, init = list(se_1 = runif(3), sp_1 = runif(3), prev_1 = 0.5))
plot(b)
b <- estimate_ML_binary(a$generated_data, init = list(se_1 = runif(3, 0.51, 0.99), sp_1 = runif(3, 0.51, 0.99), prev_1 = 0.5))
plot(b)
b <- estimate_ML_binary(a$generated_data, init = list(se_1 = runif(3, 0.51, 0.99), sp_1 = runif(3, 0.51, 0.99), prev_1 = 0.5))
plot(b)
b <- estimate_ML_binary(a$generated_data, init = list(se_1 = runif(3, 0.51, 0.99), sp_1 = runif(3, 0.51, 0.99), prev_1 = 0.1))
plot(b)
plot(b, params = a$params)
a <- generate_multimethod_data("ordinal", n_method = 4, n_level = 9)
a$generated_data
a <- generate_multimethod_data("ordinal", n_method = 4, n_level = 9, n_obs = 200)
a$generated_data
a <- generate_multimethod_data("ordinal", n_method = 4, n_level = 9, n_obs = 200, prev = 0.2)
a$generated_data
b <- estimate_ML("ordinal", data = a$generated_data)
b
#' Estimate accuracy statistics and prevalence by ML
#'
#' @inheritParams estimate_ML
#' @param level_names
#'
#' @return
#' @export
#'
#' @examples
estimate_ML_ordinal <-
function(data,
init = list(pi_1_1 = NULL, phi_1ij_1 = NULL, phi_0ij_1 = NULL, n_level = NULL),
level_names = NULL,
max_iter = 1000,
tol = 1e-7,
save_progress = TRUE){
calc_l_cond_ordinal <- function(){
l_cond <-
sum(c(
q_k0_t * log(g_0_t),
q_k1_t * log(g_1_t)
))
return(l_cond)
}
calc_A_i <- function(phi_1ij, phi_0ij){
outer_sum <- 0
for(j in 1:(n_level - 1)){
inner_sum <- colSums(phi_1ij[(j + 1):n_level, , drop = FALSE])
outer_sum <- outer_sum + phi_0ij[j, ] * inner_sum
}
A_i <- outer_sum + 0.5 * colSums(phi_1ij * phi_0ij)
return(A_i)
}
calc_y_k <- function(){
# n_method <- ncol(t_k) -> i
# n_level               -> j
# n_obs <- nrow(t_k)    -> k
y_k <- list()
for(k in 1:n_obs){
tmp_y_k <- matrix(nrow = n_level, ncol = n_method, dimnames = list(level_names, method_names))
for(j in 1:n_level){
for(i in 1:n_method){
tmp_y_k[j, i] <- as.numeric(t_k[k, i] == j)
}
}
y_k[[k]] <- tmp_y_k
}
return(y_k)
}
calc_g_d <- function(phi_dij){
g_d <- lapply(y_k, function(k) prod(phi_dij ^ k)) |> unlist() |> pmax(1e-300)
return(g_d)
}
calc_q_kd <- function(d){
q_kd <-
(p_t * g_1_t * d + (1 - p_t) * g_0_t * (1 - d)) /  # d terms added to toggle numerator
((1 - p_t) * g_0_t + p_t * g_1_t)
return(q_kd)
}
calc_next_prev <- function(q_k1){
mean(q_k1)
}
calc_next_phi_dij <- function(q_kd){
lapply(1:length(q_kd), function(k){q_kd[k] * y_k[[k]]}) |> Reduce(f = "+", x = _) /
sum(q_kd)
}
t_k <- data
n_method <- ncol(t_k)
n_obs <- nrow(t_k)
method_names <- if(is.null(colnames(t_k))){name_thing("method", n_method)}else{colnames(t_k)}
obs_names <- if(is.null(rownames(t_k))){name_thing("obs", n_obs)}else{rownames(t_k)}
if(is.null(init$n_level)){n_level <- length(unique(as.vector(t_k)))}
if(is.null(level_names)){level_names <- name_thing("level", n_level)}
if(!all(c("prev_1", "se_1", "sp_1") %in% names(init)) | any(sapply(init, is.null))){init <- pollinate_ML_ordinal(t_k, n_level = n_level, level_names = level_names)}
p_t <- init$pi_1_1
phi_1ij_t <- init$phi_1ij_1
phi_0ij_t <- init$phi_0ij_1
y_k <- calc_y_k()
list_prev <- list()
list_phi_1ij <- list()
list_phi_0ij <- list()
list_y_k <- list()
list_g_1 <- list()
list_g_0 <- list()
list_q_k1 <- list()
list_q_k0 <- list()
list_l_cond <- list()
for(iter in 1:max_iter){
g_1_t <- calc_g_d(phi_1ij_t)
g_0_t <- calc_g_d(phi_0ij_t)
q_k1_t <- calc_q_kd(d = 1)
q_k0_t <- calc_q_kd(d = 0)
l_cond_t <- calc_l_cond_ordinal()
list_prev <- c(list_prev, list(p_t))
list_phi_1ij <- c(list_phi_1ij, list(phi_1ij_t))
list_phi_0ij <- c(list_phi_0ij, list(phi_0ij_t))
list_y_k <- c(list_y_k, list(y_k))
list_g_1 <- c(list_g_1, list(g_1_t))
list_g_0 <- c(list_g_0, list(g_0_t))
list_q_k1 <- c(list_q_k1, list(q_k1_t))
list_q_k0 <- c(list_q_k0, list(q_k0_t))
list_l_cond <- c(list_l_cond, list(l_cond_t))
if(iter > 1){if(abs(list_l_cond[[iter]] - list_l_cond[[iter - 1]]) < tol){break}}
p_t <- calc_next_prev(q_k1_t)
phi_1ij_t <- calc_next_phi_dij(q_kd = q_k1_t)
phi_0ij_t <- calc_next_phi_dij(q_kd = q_k0_t)
}
output <-
new("MultiMethodMLEstimate",
results = list(
prev_est = p_t,
phi_1ij_est = phi_1ij_t,
phi_0ij_est = phi_0ij_t,
q_k1_est = q_k1_t),
iter = iter,
type = "ordinal")
if(save_progress){
output@prog <-
list(
prev = list_prev,
phi_1ij = list_phi_1ij,
phi_0ij = list_phi_0ij,
y_k = list_y_k,
g_1 = list_g_1,
g_0 = list_g_0,
q_k1 = list_q_k1,
q_k0 = list_q_k0,
l_cond = list_l_cond)
}
return(output)
}
b <- estimate_ML("ordinal", data = a$generated_data)
View(b)
a <- generate_multimethod_data("ordinal", n_method = 4, n_level = 9, n_obs = 200, prev = 0.2)
b <- estimate_ML("ordinal", data = a$generated_data)
b@prog[["y_k"]][[1]][[1]]
?rbind
bind_rows(b@prog$phi_0ij, .id = "iter")
rlang::last_trace()
rlang::last_trace(drop = FALSE)
do.call(rbind, b@prog$phi_1ij)
do.call(rbind, as.data.frame(b@prog$phi_1ij))
as.data.frame(b@prog$phi_1ij)
sapply(b@prog$phi_1ij, as.data.frame)
sapply(b@prog$phi_1ij, as.data.frame) %>% bind_rows
lapply(b@prog$phi_1ij, as.data.frame) %>% bind_rows
?seq_along
?apply
?mapply
?map
lapply(b@prog$phi_1ij, function(i) tmp <- cbind(ID = which(i == b@prog$phi_1ij), i))
